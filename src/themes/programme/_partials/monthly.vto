<h2>Events and audiences by month</h2>

{{>
	function decimalYear(p1){
		if(typeof p1==="string") p1 = new Date(p1);
		let sy = new Date(p1);
		// Start of year
		sy.setUTCMonth(0);
		sy.setUTCDate(1);
		sy.setUTCHours(0);
		sy.setUTCMinutes(0);
		sy.setUTCSeconds(0);
		// Start of next year
		let ey = new Date(sy);
		ey.setUTCFullYear(sy.getUTCFullYear()+1);
		p1 = sy.getUTCFullYear() + (p1-sy)/(ey-sy);
		return p1;
	}
	function getTimeTicks(){
		let ticks = [];
		for(let y = 2024; y <= 2025; y++){
			for(i = 0, m = 1; m <= 12 ; i++, m++){
				let d = y + "-" + (m<10 ? '0':'') + m + '-01';
				let tick = {value:decimalYear(d),tickSize:4};
				if(m==1){
					if(y==2024) tick.grid = true;
					tick.label = y + '';
					tick.tickSize = 10;
				}
				ticks.push(tick);
			}
		}
		return ticks;
	}
	
	function getYAxis(data,key,scale){
		if(!scale) scale = {};
		let min = Infinity,max = -Infinity,range,spacing,lo,hi,axis,i,y,pre = "",post = "",f = 1;
		// Calculate the min/max in the data and get the pre/post units
		for(i = 0; i < data.length; i++){
			if(!isNaN(data[i][key])){
				min = Math.min(min,data[i][key]);
				max = Math.max(max,data[i][key]);
			}
			if(i==0){ pre = data[i].preunit||""; post = data[i].postunit||""; }
		}
		// If the scale minimum is set we'll use that instead (this helps preserve some sensible zero scaling)
		if(typeof scale.min==="number") min = scale.min;
		// Find the range
		range = max - min;
		// Work out a spacing and then a scale factor
		if(range > 0){
			spacing = Math.pow(10,Math.floor(Math.log10(range)));
			let n = range/spacing;
			if(n > 6) f = 2;
		}else{
			spacing = 1;
		}
		// Update the tick spacing
		spacing *= f;
		// Find the new minimum/maximum to use for the scale
		lo = Math.floor(min/spacing)*spacing;
		hi = Math.floor(max/spacing)*spacing;
		//axis = {min:lo.toNumber(),max:hi.toNumber(),ticks:[],'grid':{'stroke-width': 0.5}};
		var ticks = [];
		for(y = lo; y <= hi ; y += spacing){
			// Round the number in case of errors
			y = Math.floor(y/spacing)*spacing;
			ticks.push({'value':y,'label':(pre+y.toLocaleString()+post),'grid':true});
		}
		return ticks;
	}


    function makeTooltip(row,type) {
        const tooltip = [];

		if(type == "events"){
			tooltip.push(row.Events.toLocaleString() + " events in " + row.Month);
		}else if(type == "audience"){
			tooltip.push(row.Audience.toLocaleString() + " in " + row.Month);
		}
		tooltip.push('<br /><a href="#' + row.iso + '">See details below</a>');
        return tooltip.join('');
    }
	function buildEventRows(row){
		const rows = [];
		for (const p of Object.entries(row.projects)) {
			rows.push({'Project': p[0], 'Events': p[1]});
		}
		return rows;
	}
    const eventsByMonth = events.total_by_month.map(row => ({
        ...row,
        projects: Object.entries(events.monthly_breakdown.find(r => row.month.toISOString() == r.month.toISOString()))
            .filter(r => (r[0] !== 'month') && (r[1] > 0))
            .toSorted((a, b) => b[1] - a[1])
            .reduce((a, c) => ({...a, [c[0]]: c[1]}), {}),
        Month: row.month.toLocaleDateString(undefined, { month: "long", year: "numeric" }),
        iso: row.month.toISOString().substr(0,7),
        decimal_year: decimalYear(row.month)
    }))
    .map(r => ({
        ...r,
        tooltipEvents: makeTooltip(r,"events"),
        tooltipAudience: makeTooltip(r,"audience"),
		events: buildEventRows(r),
    }));


}}

{{ comp dashboard.Frame }}
	{{ comp dashboard.Cell }}
		{{ comp.oi.chart.line({
			config: {
				height: 300,
				width: 800,
				data: eventsByMonth,
				axis: {
					y: {
						min: 0,
						ticks: getYAxis(eventsByMonth,"Events")
					},
					x: {
						min: 2024,
						ticks: getTimeTicks()
					}
				},
				series: [
					{ "y": "Events", "x": "decimal_year", "title": "Events", "colour": oiColour.names.yellow, "tooltip": "tooltipEvents" },
				],
			},
		}) }}
	{{ /comp }}
	{{ comp dashboard.Cell }}
		{{ comp.oi.chart.line({
			config: {
				height: 300,
				width: 800,
				data: eventsByMonth,
				axis: {
					y: {
						min: 0,
						ticks: getYAxis(eventsByMonth,"Audience")
					},
					x: {
						min: 2024,
						ticks: getTimeTicks()
					}
				},
				series: [
					{ y: 'Audience', x: "decimal_year", title: 'Audience', colour: oiColour.names.green, "tooltip": "tooltipAudience" },
				],
			},
		}) }}
	{{ /comp }}
{{ /comp }}

<h3>Monthly breakdown</h3>
{{ for item of eventsByMonth }}
<div id="{{ item.iso }}">
	<h4 class="month">{{ item.Month }}</h4>
	<p>Audience: {{ item.Audience.toLocaleString() }}, Events: {{ item.Events.toLocaleString() }}</p>
	{{ comp Details {'summary':'Event details' } }}
		{{ comp.oi.table({
			config: {
				data: item.events,
				columns: [
					{name:'Project',sortable:true,th:true},
					{name:'Events',sortable:true,class:'centred',scale:scales.yellow}
				],
				head: { class: 'c-yellow' }
			}
		}) }}
	{{ /comp }}
</div>
{{ /for }}

<style>
h4.month { margin-bottom: 0; }
h4.month + p { margin-block: 0.25rem; }
details summary:focus { outline: 0; }
</style>

{{# This script will open a <details> if the anchor #}}
<script>
function ready(fn){
	if(document.readyState != 'loading') fn();
	else document.addEventListener('DOMContentLoaded', fn);
}
function openDetailsIfAnchorHidden(target){
	const elTarget = document.getElementById(target);
	if (!elTarget) return; // No such element in DOM. Do nothing
	// Open all <details> ancestors
	let elDetails = elTarget.querySelector('details');
	while (elDetails) {
		if (elDetails.matches("details")) elDetails.open = true;
		elDetails = elDetails.parentElement;
	}
}

ready(function(){
	// Attach event
	window.addEventListener("popstate", (event) => {
		openDetailsIfAnchorHidden(location.href.substr(location.href.indexOf('#')+1));
	});
	const anchor = location.href.split("#")[1];
	if(anchor) openDetailsIfAnchorHidden(anchor);
});
</script>
	


