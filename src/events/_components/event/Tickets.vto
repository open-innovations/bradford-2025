{{ if tickets.by_geography || tickets.by_type || tickets.by_event }}
<h2>Tickets</h2>
{{ /if }}


{{ if tickets?.by_geography && (tickets?.by_geography.length > 0) }}
<section>

	<h3>Geographic ticket allocation</h3>
	{{> const by_ward = tickets.by_geography
			.filter(x => x.start == 'ALL' && x.geography_type == 'osward' && x.geography_code !== 'OTHER')
			.map(w => ({
				...w,
				...geojson.bd_wards.features.map(x => x.properties).find(x => x.WD24CD === w.geography_code)
			}))
	}}
	{{> const minTickets = 20; }}
	{{>
		let oslauaTickets = tickets.by_geography
		.map(x => ({ geography_code: "UNKNOWN", ...x }))
		.filter(
			x => x.start === 'ALL' && x.geography_type === 'oslaua' && x.count_of_tickets > minTickets
		)
		.sort((a, b) => b.count_of_tickets - a.count_of_tickets)
		.map(x => ({ ...x, name: codes.la[x.geography_code]?.name || x.geography_code }));

		const unmatched = oslauaTickets.find(x => x.geography_code === 'UNMATCHED');
		const missing = oslauaTickets.find(x => x.geography_code === 'MISSING');

		oslauaTickets = oslauaTickets.filter(obj => obj.geography_code !== 'UNMATCHED').filter(obj => obj.geography_code !== 'MISSING');
		
	}}

	{{ comp Tab.Set { classes: 'big'} }}
		{{ comp Tab.Panel { id: 'hex-tickets', label: 'Wards: hexes' } }}
			<p>Tickets sold across the wards of Bradford.</p>
			{{ comp.oi.map.hex_cartogram({
				config: {
					data: by_ward,
					scale: scales.yellow,
					value: 'count_of_tickets',
					tooltip: '<b>{{ WD24NM }}</b>:\n{{ count_of_tickets }} tickets sold',
					hexjson: hexes.bd_2024,
					matchKey: 'geography_code',
					label: 'short_code',
					tools: {
						filter: {
							label: 'n',
							position: 'top left'
						},
						panzoom: {
							maxZoom: 3,
							scrollWheelZoom: false
						}
					}
				}
			}) }}
			<figcaption>Schematic presentation of tickets sold by Bradford Ward.</figcaption>
			<p class="footer">This is a hex cartogram that shows each ward area with the same-sized hexagon. This allows us to treat areas equally in the visualisation but at the expense of an accurate geographic layout. Switch to the geographic map for accurate geography.</p>
		{{ /comp }}
		{{ comp Tab.Panel { id: 'geo-tickets', label: 'Wards: geographic' } }}
			<p>Tickets sold across the wards of Bradford.</p>
			{{ comp.oi.map.svg({
				config: {
					data: by_ward,
					scale: scales.yellow,
					value: 'count_of_tickets',
					tooltip: '<b>{{ WD24NM }}</b>:\n{{ count_of_tickets }} tickets sold',
					geojson: { key: "WD24CD", data: geojson.bd_wards },
					key: 'geography_code',
					label: 'short_code',
					tools: {
						filter: {
							label: 'filterLabel',
							position: 'top left'
						},
						panzoom: {
							maxZoom: 6,
							scrollWheelZoom: false
						}
					}
				}

			}) }}
			<figcaption>Schematic presentation of tickets sold by Bradford Ward.</figcaption>
		{{ /comp }}
		{{ comp Tab.Panel { id: 'tab-tickets', label: 'Local authorities' } }}
			<p>Tickets were issued to attendees from the following Local Authorities.
			This list contains any Local Authority with a count of more than {{ minTickets }} tickets:</p>

			{{ comp.dashboard.InfoBoxTable({
				head: {
					class: 'c-yellow',
				},
				columns: [
					{ label: 'Local Authority', name: 'name' },
					{ label: 'Count of tickets', name: 'lad', template: '{{ count_of_tickets | toLocaleString() }}', value: 'count_of_tickets', class: 'right', scale: scales.yellow, min: 0 }
				],
				data: oslauaTickets,
				width: "100%",
				sort: "name"
			}) }}

			<p>
			{{ if missing }}
			There were
			<b>{{ missing.count_of_tickets.toLocaleString() }} tickets</b>
			orders either missing a postcode or associated with a postcode which cannot be mapped to a local authority.
			{{ /if }}
			{{ if unmatched }} There were also
			<b>{{ unmatched.count_of_tickets.toLocaleString() }} tickets</b>
			that could not be assigned to a local authority, either as they were outside the UK,
			or the ticket holder's postcode was invalid.
			{{ /if }}
			</p>

		{{ /comp }}
	{{ /comp }}

</section>
{{ /if }}


{{ if tickets?.by_type && (tickets?.by_type.length > 0) }}
{{>
    function ticketReducer(a, c) {
        const key = c.type;
        return { ...a, [key]: c.percentage + (a[key] || 0)};
    }

    const ticketsByType = tickets.by_type.reduce(ticketReducer, {});

    const series = [
            {
                value: 'Full Price', title: 'Full price', colour: '#F4ACCD',
                tooltip: 'Full price tickets <b>{{ Full Price }}%</b>',
            },
            {
                value: 'Child Ticket', title: 'Child', colour: '#45D108',
                tooltip: 'Child tickets <b>{{ Child Ticket }}%</b>',
            },
            {
                value: 'Senior Ticket', title: 'Senior', colour: '#E0B942',
                tooltip: 'Senior tickets <b>{{ Senior Ticket }}%</b>',
            },
            {
                value: 'Community Ticket', title: 'Community', colour: '#e1699f',
                tooltip: 'Community tickets <b>{{ Community Ticket }}%</b>',
            },
            {
                value: 'Bradford Youth Pass', title: 'Youth Pass', colour: '#437e2a',
                tooltip: 'Bradford Youth Pass tickets <b>{{ Bradford Youth Pass }}%</b>',
            },
            {
                value: 'Accessible Ticket', title: 'Accessible', colour: '#be9006',
                tooltip: 'Accessible tickets <b>{{ Accessible Ticket }}%</b>',
            },
            {
                value: 'Other', title: 'Other', colour: '#F8D9E7',
                tooltip: 'Other tickets <b>{{ Other }}%</b>',
            },
        ].filter(x => Object.keys(ticketsByType).includes(x.value));
}}

<h3>Ticket types</h3>
<section class="grid regular">
	<div class="block">
 
		<figure>
		{{ comp.oi.chart.waffle({
			config: {
				data: [tickets.by_type.reduce(ticketReducer, {})],
				size: [20, 15],
				series: series,
				legend: {
					show: true,
					position: 'bottom',
				},
			}
		}) }}
		<figcaption>
			Proportion of ticket types sold by type of ticket.
		</figcaption>
		</figure>
	</div>
	<div>
		<p>The graph to shows the percentage of tickets by type of ticket.</p>
		<p>Tickets types are as described below</p>
		<ul>
		<li>
			<b>Child Tickets</b> and <b>Senior Tickets</b> are concessionary tickets based on age.
			These might differ from event to event.
		</li>
		<li>
		{{# TODO update description based on feedback from Richard Dunbar #}}
			<b>Community Tickets</b> are distributed to specific communities by the Bradford 2025 team.
		</li>
		<li>
			<b>Accessible Tickets</b> includes <b>BSL Interpreted</b>, <b>Audio Description</b>, <b>Wheelchair User</b> and <b>Essential Companion</b> tickets
		</li>
		</ul>
	</div>
</section>
{{ /if }}


{{ if tickets.by_event && (tickets?.by_event.length > 0) }}
<section>
	<h3>Tickets by event</h3>
	{{ comp.dashboard.InfoBoxTable({
		head: {
			class: 'c-yellow',
		},
		columns: [
			{ label: 'Event name', name: 'event_name' },
			{ label: 'Event start time', name: 'start_date', template: '{{ start | strptime("%Y-%m-%dT%H:%M") | strftime("%e %B %Y %H:%M") }}',value: 'start' },
			{ label: 'Tickets sold', name: 'tickets_sold', template: '{{ tickets | toLocaleString() }}', value: 'tickets', class: 'right', scale: scales.yellow, min: 0 }
		],
		data: tickets.by_event,
		width: "100%"
	}) }}
</section>

{{ /if }}